---
title: Implementing a File Archive with the DAL and a Smart Rollup
authors: 'Tezos Core Developers'
last_update:
  date: 17 January 2024
---

import LucidDiagram from '@site/src/components/LucidDiagram';

The data availability layer (DAL) is a companion peer-to-peer network for the Tezos blockchain, designed to provide additional bandwidth to Smart Rollups.
It allows users to share large amounts of data in a way that is decentralized and permissionless, because anyone can join the network and post and read data on it.
For more information about the DAL, see [The Rollup Booster: A Data-Availability Layer for Tezos](https://research-development.nomadic-labs.com/data-availability-layer-tezos.html).

In this tutorial, you will set up a file archive that stores and retrieves files with the DAL.
You will learn:

- How data is organized and shared with the DAL and the reveal data channel
- How to read data from the DAL in a Smart Rollup
- How to host a DAL node
- How to publish data and files with the DAL

Because the DAL is not yet available on Tezos Mainnet, this tutorial uses the [Weeklynet test network](https://teztnets.xyz/weeklynet-about), which runs on a newer version of the protocol that includes the DAL.

## Prerequisites

This article assumes some familiarity with Smart Rollups.
If you are new to Smart Rollups, see the tutorial [Deploy a Smart Rollup](./smart-rollup).

### Set up a Weeklynet environment and account

Because Weeklynet requires a specific version of the Octez suite, you can't use most wallet applications and installations of the Octez suite with it.
Instead, you must set up an environment with a specific version of the Octez suite and use it to create and fund an account.
Note that Weeklynet is reset every Wednesday, so you must recreate your environment and account after the network resets.

The easiest way to do this is to use the Docker image that is generated each time Weeklynet is reset and recreated.
As another option, you can build the specific version of the Octez suite locally.
For instructions, see the Weeklynet page at https://teztnets.xyz/weeklynet-about.

To set up an environment and account in a Docker container, follow these steps:

1. From the [Weeklynet](https://teztnets.xyz/weeklynet-about) page, find the Docker command to create a container from the correct Docker image, as in this example:

   ```bash
   docker run -it --entrypoint=/bin/sh tezos/tezos:master_7f3bfc90_20240116181914
   ```

   The image tag in this command changes each time the network is reset.

1. Copy the URL of the public RPC endpoint for Weeklynet, such as `https://rpc.weeklynet-2024-01-17.teztnets.com`.
This endpoint also changes each time the network is reset.

1. For convenience, you may want to set this endpoint as the value of the `ENDPOINT` environment variable.

1. In the container, initialize the Octez client with that endpoint, such as this example:

   ```bash
   octez-client -E https://rpc.weeklynet-2024-01-17.teztnets.com config init
   ```

1. Create an account with the command `octez-client gen keys $MY_ACCOUNT`, where `$MY_ACCOUNT` is an alias for your account.

1. Get the public key hash of the new account by running the command `octez-client show address $MY_ACCOUNT`.

1. From the [Weeklynet](https://teztnets.xyz/weeklynet-about) page, open the Weeklynet faucet and send some tez to the account.

Now you can use this account to deploy Smart Rollups.

### Install Rust

To run this tutorial, install Rust by running the following command.
The application in this tutorial uses Rust because of its support for WebAssembly (WASM), the language that Smart Rollups use to communicate.
Rollups can use any language that has WASM compilation support.

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Then, add WASM as a compilation target for Rust by running this command:

```bash
rustup target add wasm32-unknown-unknown
```

You can see other ways of installing Rust at https://www.rust-lang.org.

## Why the DAL?

The DAL has earned the nickname "Rollup Booster" from its ability to address
the last bottleneck Smart Rollups developers could not overcome without
sacrificing decentralization: block space. Smart Rollups offload
*computation* from layer 1, but the transactions that they process still need to
originate from somewhere.

By default, that "somewhere" is the layer 1 blocks, yet the size of a Tezos
block is limited to around 500KBytes. In this model, while Smart Rollups do not
compete for layer 1 gas anymore, they still compete for block space.

{/* Is this info about the reveal data channel needed here? */}
Additionally, a Smart Rollup can fetch data from an additional source called the
reveal data channel, which allows them to retrieve arbitrary data.
The reveal channel is a powerful way to share data, because it allows a Smart Rollup
operator to post hashes instead of full data files on layer 1. But it is a
double-edged sword, because nothing enforces the availability of the data in the
first place. [Solutions exist to address this
challenge](https://research-development.nomadic-labs.com/introducing-data-availability-committees.html),
but they are purely off-chain ones, coming with no guarantee from layer 1.

The DAL allows third parties to publish data and have bakers attest that the data is available.
When enough bakers have attested that the data is available, Smart Rollups can retrieve the data without the need for additional trusted third-parties.

## How the DAL works

In this tutorial, you create a file archive application that allows clients to upload data to the DAL.
You also create a Smart Rollup that listens to the DAL and responds to that data.

The DAL works like this:

1. Users post data to a DAL node.
1. The DAL node returns a certificate.
This certificate includes a commitment that the data is available and a proof of the data.
1. Users post the certificate to layer 1 via the Octez client, which is much cheaper than posting the complete data.
1. When the certificate is confirmed in a block, layer 1 splits the data into shards and assigns those shards to bakers, who verify that the data is available.
1. Bakers verify that the data is available and attest that the data is available in their usual block attestations to layer 1.
They have a certain number of blocks to do so, known as the _attestation lag_, and if they don't by the end of this period, the certificate is considered bogus and the related data is dropped.
1. Other DAL nodes get the data from the initial DAL node through the peer-to-peer network.
1. The Smart Rollup node monitors the blocks and when it sees attested DAL data, it connects to a DAL node to request the data.
1. The Smart Rollup node stores the file in its durable storage, addressed by its hash.
1. Users who know the hash of the file can download it from the Smart Rollup node.

The overall workflow is summarized in the following figure:

<LucidDiagram width="640px" height="480px" src="https://lucid.app/documents/embedded/cc422278-7319-4a2f-858a-a7b72e1ea3a6" id="ljs6hoejIr1H" />

There are many steps in the DAL process, but the most complicated parts (storing and sharing files) are handled automatically by the various daemons in the Octez suite.

:::note The Smart Rollup does not support the DAL
As of today, the Smart Rollup Installer does not support DAL as a
Data-Availability solution. This means we will need to rely on the reveal
channel to initialize our Smart Rollup correctly (which is not ideal for a
decentralized file archive).
:::

When your environment is ready, get started by going to [Part 1: Getting the DAL parameters](./build-files-archive-with-dal/get-dal-params).




### Task 4. Fetching and Storing the Full Slot

There is only one thing left in order to complete our file archive. We can do
that by modifying the `run` function as follows.


```rust
pub fn run<R: Runtime>(
    host: &mut R,
    param: &RollupDalParameters,
    index: u8,
) -> Result<(), RuntimeError> {
    // Reading one message from the shared inbox is always safe,
    // because the shared inbox contains at least 3 messages per
    // Tezos block.
    let sol = host.read_input()?.unwrap();

    let target_level = sol.level as usize - param.attestation_lag as usize;

    let mut buffer = vec![0u8; param.slot_size as usize];

    let bytes_read = host.reveal_dal_page(target_level as i32, index, 0, &mut buffer)?;

    if bytes_read == 0 {
        debug_msg!(
            host,
            "No attested slot at index {} for level {}\n",
            index,
            target_level
        );

        return Ok(());
    }

    debug_msg!(
        host,
        "Attested slot at index {} for level {}\n",
        index,
        target_level
    );

    let num_pages = param.slot_size / param.page_size;

    for page_index in 1..num_pages {
        let _result = host.reveal_dal_page(
            target_level as i32,
            index,
            page_index.try_into().unwrap(),
            &mut buffer[page_index as usize * (param.page_size as usize)
                ..(page_index as usize + 1) * (param.page_size as usize)],
        );
    }

    let hash = blake2b::digest(&buffer, 32).unwrap();
    let key = hex::encode(hash);
    let path = OwnedPath::try_from(format!("/{}", key)).unwrap();

    debug_msg!(host, "Saving slot under `{}'\n", path);

    let () = host.store_write_all(&path, &buffer)?;

    Ok(())
}
```

There is a bit to unpack here.

1. First, we allocate a buffer of the size of a slot, not a size of the page.
2. Second, we try to fetch the contents of the first page. If 0 bytes are
   written by `reveal_dal_page`, then we know the targeted slot has not been
   attested for this block, and we have nothing left to do.
3. Otherwise, we read as many page as necessary to get the full slot.
4. Once itâ€™s done, we store said slot in the durable storage, using the Blake2B
   hash (encoded in hexadecimal) as its key.

We use two additional dependencies for this: `tezos_crypto_rs` for hashing, and
`hex` for encoding.

```diff
+use tezos_crypto_rs::blake2b;
+use tezos_smart_rollup::storage::path::OwnedPath;
 use tezos_smart_rollup::{host::RuntimeError, kernel_entry, prelude::*};
 use tezos_smart_rollup_host::dal_parameters::RollupDalParameters;
```

```diff
 [dependencies]
 tezos-smart-rollup = { version = "0.2.2", features = [ "proto-alpha" ] }
 tezos-smart-rollup-host = { version = "0.2.2", features = [ "proto-alpha" ] }
+tezos_crypto_rs = { version = "0.5.2", default-features = false }
+hex = "0.4.3"
```

:::note
Adding `default-features = false` for `tezos_crypto_rs` is necessary for the
crate to be compatible with Smart Rollups.
:::

Deploy your Smart Rollup again, publish a file, wait for enough levels, and you
should see a line of log giving you the hash used to register the slot.

Assuming you have set the `hash` variable accordingly, then you can check the
file indeed exists (and later use `hexdump -C` to inspect its contents.

```bash
curl "http://localhost:8932/global/block/head/durable/wasm_2_0_0/value?key=/${hash}" \
    -H 'Content-Type: application/octet-stream' \
    -o slot.bin
```

:::note Why `diff` wonâ€™t work
You cannot use `diff` to ensure the file you originally published and the one
you downloaded from the rollup node are equal. Indeed, they are not: since
the size of a slot is fixed, the DAL node pads the value it receives from
`POST /slot`. in order to ensure it has the correct size.
:::

## Conclusion

Our file archive is now completed. At least, the features we wanted to
implement are there: a Smart Rollup storing in its durable storage the slots
attested at a given index.

From there, the skyâ€™s the limit. More features could be implemented, like
having the files publishers pay for the storage they are using in Layer 2 (by
allowing them to deposit tez to the Smart Rollup, and sign the files they
publish). We could also build a frontend to visualize the files published in
our archive. Or, we could deal with the fact that for now, it is not possible
for a consumer of the file to know itâ€™s original size (we could fix that by
modifying the script we use to publish a file to prefix it with its size).

